<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Aftermath — Hard Mode (8×8)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --stroke:rgba(255,255,255,.12);
      --ink:#e7eefc;
      --muted:#9fb0cc;
      --shadow: 0 16px 44px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(122,167,255,.18), transparent 55%),
        radial-gradient(900px 700px at 90% 10%, rgba(255,204,102,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding:18px 16px 22px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:16px;
      align-items:start;
    }
    header{
      grid-column:1 / -1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:14px 14px;
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
    }
    .brand{ display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .brand h1{ margin:0; font-size:16px; letter-spacing:.3px; font-weight:900;}
    .brand .sub{ color:var(--muted); font-size:12px; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    button{
      appearance:none;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--ink);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight:800;
      font-size: 13px;
    }
    button:hover{ background: rgba(255,255,255,.07); border-color: rgba(122,167,255,.35); }
    button:active{ transform: translateY(1px); }

    .stage{
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      padding:14px;
    }
    .topline{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px; margin-bottom:10px; flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background:#ffcc66;
      box-shadow:0 0 0 3px rgba(255,204,102,.14);
    }
    .boardWrap{ display:flex; justify-content:center; align-items:center; }
    canvas{
      width: 100%;
      max-width: 640px;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.26);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      user-select:none;
      touch-action:none;
      display:block;
    }
    .sidebar{
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .card{
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      border-radius: 16px;
      padding: 12px;
    }
    .card h2{ margin:0 0 8px; font-size: 14px; letter-spacing:.2px; }
    .card p{ margin:0; color:var(--muted); font-size: 13px; line-height:1.45; }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .stat{
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .stat .label{ color:var(--muted); font-size:12px; }
    .stat .value{ font-size:18px; font-weight: 950; margin-top:2px; }
    .hint{
      border-top:1px solid var(--stroke);
      padding-top:12px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .kbd{
      display:inline-block;
      padding:1px 6px;
      border:1px solid var(--stroke);
      border-radius: 8px;
      background: rgba(255,255,255,.04);
      color: var(--ink);
      font-size: 12px;
      font-weight: 900;
      margin:0 2px;
    }
    .mini{
      display:flex; gap:10px; align-items:center; margin-top:10px;
    }
    .mini canvas{
      max-width: 120px;
      border-radius: 14px;
    }
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.55);
      color: var(--ink);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      box-shadow: var(--shadow);
      z-index: 50;
      max-width: min(680px, calc(100vw - 32px));
      text-align:center;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-4px); }

    @media (max-width: 920px){
      .app{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <h1>Aftermath — Hard</h1>
        <div class="sub">8×8 board • aftershock pushes 2 cells • score only from clears</div>
      </div>
      <div class="row">
        <button id="newRun">New Run</button>
        <button id="undo">Undo</button>
      </div>
    </header>

    <section class="stage">
      <div class="topline">
        <div class="pill"><span class="dot"></span> Tap/Click place • <b>R</b> rotate • <b>U</b> undo</div>
        <div class="pill" id="statusPill">Alive</div>
      </div>
      <div class="boardWrap">
        <canvas id="c" width="800" height="800"></canvas>
      </div>
    </section>

    <aside class="sidebar">
      <div class="card">
        <h2>Stats</h2>
        <div class="stats">
          <div class="stat"><div class="label">Score</div><div class="value" id="score">0</div></div>
          <div class="stat"><div class="label">Moves</div><div class="value" id="moves">0</div></div>
          <div class="stat"><div class="label">Next Aftershock</div><div class="value" id="shock">←</div></div>
          <div class="stat"><div class="label">Last Chain</div><div class="value" id="chain">0</div></div>
        </div>

        <div class="mini">
          <div style="flex:1">
            <p style="margin:0;color:var(--muted);font-size:12px;line-height:1.35;">
              Current: <b id="curName">—</b><br>
              Next: <b id="nextName">—</b>
            </p>
          </div>
          <canvas id="mini" width="200" height="200" aria-label="Next piece preview"></canvas>
        </div>
      </div>

      <div class="card">
        <h2>Rules</h2>
        <p>
          Each move: <b>place</b> → <b>gravity</b> → <b>aftershock</b> (2-cell push ←/→ alternating) → <b>clear rows</b> → repeat if chain.
          <br><br>
          You score only when you clear rows. Spam placing will end the run quickly with low score.
        </p>
      </div>

      <div class="hint">
        Strategy: plan for the 2-cell shove. Place shapes so the aftershock “fixes” them into rows.
        <br><br>
        Controls: <span class="kbd">Tap/Click</span> place, <span class="kbd">R</span> rotate, <span class="kbd">U</span> undo.
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const mini = document.getElementById('mini');
  const mctx = mini.getContext('2d');

  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const shockEl = document.getElementById('shock');
  const chainEl = document.getElementById('chain');
  const statusPill = document.getElementById('statusPill');
  const toastEl = document.getElementById('toast');
  const curNameEl = document.getElementById('curName');
  const nextNameEl = document.getElementById('nextName');

  const N = 8;               // smaller board = harder
  const AFTERSHOCK_PUSH = 2; // stronger push = harder
  const CELL_GAP = 8;
  const PAD = 32;

  const PIECES = [
    { name: "I", cells: [[0,0],[1,0],[2,0],[3,0]] },
    { name: "O", cells: [[0,0],[1,0],[0,1],[1,1]] },
    { name: "T", cells: [[0,0],[1,0],[2,0],[1,1]] },
    { name: "L", cells: [[0,0],[0,1],[0,2],[1,2]] },
    { name: "J", cells: [[1,0],[1,1],[1,2],[0,2]] },
    { name: "S", cells: [[1,0],[2,0],[0,1],[1,1]] },
    { name: "Z", cells: [[0,0],[1,0],[1,1],[2,1]] },
  ];

  const COLORS = {
    I: [122,167,255],
    O: [255,204,102],
    T: [178,122,255],
    L: [255,143,92],
    J: [72,211,138],
    S: [255,122,185],
    Z: [120,220,255],
  };

  let grid;
  let current, next;
  let rot = 0;
  let hover = null;
  let alive = true;

  let score = 0;
  let moves = 0;
  let lastChain = 0;

  const history = [];

  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove('show'), 900);
  }

  function newGrid(){
    return Array.from({length:N}, () => Array(N).fill(null));
  }
  function copyGrid(g){ return g.map(r => r.slice()); }
  function randChoice(a){ return a[(Math.random()*a.length)|0]; }

  function rotateCells(cells, r){
    let out = cells.map(([x,y]) => [x,y]);
    for(let i=0;i<r;i++) out = out.map(([x,y]) => [y, -x]);
    let minX=Infinity,minY=Infinity;
    for(const [x,y] of out){ minX=Math.min(minX,x); minY=Math.min(minY,y); }
    return out.map(([x,y]) => [x-minX, y-minY]);
  }
  function bounds(cells){
    let mx=0,my=0;
    for(const [x,y] of cells){ mx=Math.max(mx,x); my=Math.max(my,y); }
    return {w:mx+1,h:my+1};
  }

  function pushHistory(){
    history.push({
      grid: copyGrid(grid),
      current: JSON.parse(JSON.stringify(current)),
      next: JSON.parse(JSON.stringify(next)),
      rot, score, moves, lastChain, alive
    });
    if(history.length > 30) history.shift();
  }
  function undo(){
    const s = history.pop();
    if(!s) return;
    grid = copyGrid(s.grid);
    current = s.current;
    next = s.next;
    rot = s.rot;
    score = s.score;
    moves = s.moves;
    lastChain = s.lastChain;
    alive = s.alive;
    updateUI(); draw();
    showToast("Undo");
  }

  function nextShockDir(){
    // moves increments after placement, so "next" is based on current moves
    return (moves % 2 === 0) ? "←" : "→";
  }

  function canPlaceAt(x0,y0){
    const cells = rotateCells(current.cells, rot);
    for(const [dx,dy] of cells){
      const x = x0+dx, y=y0+dy;
      if(x<0||x>=N||y<0||y>=N) return false;
      if(grid[y][x] !== null) return false;
    }
    return true;
  }

  function hasAnyMove(){
    const piece = current;
    for(let r=0;r<4;r++){
      const cells = rotateCells(piece.cells, r);
      const b = bounds(cells);
      for(let y=0;y<=N-b.h;y++){
        for(let x=0;x<=N-b.w;x++){
          let ok = true;
          for(const [dx,dy] of cells){
            if(grid[y+dy][x+dx] !== null){ ok=false; break; }
          }
          if(ok) return true;
        }
      }
    }
    return false;
  }

  function advanceBag(){
    current = next;
    next = randChoice(PIECES);
    rot = 0;
  }

  function place(x0,y0){
    if(!alive) return;
    if(!canPlaceAt(x0,y0)){ showToast("Can't place"); return; }

    pushHistory();

    const cells = rotateCells(current.cells, rot);
    for(const [dx,dy] of cells){
      grid[y0+dy][x0+dx] = current.name;
    }

    moves += 1;
    lastChain = runAftermath();

    advanceBag();

    alive = hasAnyMove();
    updateUI(); draw();

    if(!alive){
      showToast("No legal moves");
    } else if(lastChain > 0){
      showToast(`Chain x${lastChain}`);
    } else {
      showToast("Placed");
    }
  }

  function applyGravity(){
    let moved=false;
    for(let x=0;x<N;x++){
      const stack=[];
      for(let y=N-1;y>=0;y--){
        const v=grid[y][x];
        if(v!==null) stack.push(v);
      }
      for(let y=N-1;y>=0;y--){
        const nv = stack[N-1-y] ?? null;
        if(grid[y][x] !== nv) moved=true;
        grid[y][x]=nv;
      }
    }
    return moved;
  }

  function aftershockPush(dir){
    // Repeat 1-cell shove AFTERSHOCK_PUSH times
    let movedAny=false;
    for(let k=0;k<AFTERSHOCK_PUSH;k++){
      let moved=false;
      if(dir==="←"){
        for(let y=0;y<N;y++){
          for(let x=1;x<N;x++){
            if(grid[y][x]!==null && grid[y][x-1]===null){
              grid[y][x-1]=grid[y][x]; grid[y][x]=null; moved=true;
            }
          }
        }
      } else {
        for(let y=0;y<N;y++){
          for(let x=N-2;x>=0;x--){
            if(grid[y][x]!==null && grid[y][x+1]===null){
              grid[y][x+1]=grid[y][x]; grid[y][x]=null; moved=true;
            }
          }
        }
      }
      if(moved) movedAny=true;
    }
    return movedAny;
  }

  function clearFullRows(){
    let cleared=0;
    const keep=[];
    for(let y=0;y<N;y++){
      const full = grid[y].every(v => v!==null);
      if(full) cleared++;
      else keep.push(grid[y]);
    }
    while(keep.length < N) keep.unshift(Array(N).fill(null));
    grid = keep;
    return cleared;
  }

  function runAftermath(){
    const dir = nextShockDir();
    shockEl.textContent = dir;

    let chain=0;
    while(true){
      applyGravity();
      aftershockPush(dir);

      const cleared = clearFullRows();
      if(cleared === 0){
        applyGravity();
        break;
      }

      chain++;

      // Scoring (only from clears)
      // More punishing board => higher reward
      const base = 260;
      const multi = cleared * cleared;                 // 1->1,2->4,3->9
      const chainMult = 1 + (chain-1) * 0.9;           // chains matter more in hard mode
      score += Math.floor(base * multi * chainMult);
    }
    return chain;
  }

  // Drawing
  function roundedRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    mctx.beginPath(); // (reuse for mini too sometimes)
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawBoard(){
    const W=canvas.width,H=canvas.height;
    ctx.clearRect(0,0,W,H);

    const gridSize=Math.min(W,H)-PAD*2;
    const cell=Math.floor((gridSize-(N-1)*CELL_GAP)/N);
    const startX=Math.floor((W-(cell*N+CELL_GAP*(N-1)))/2);
    const startY=Math.floor((H-(cell*N+CELL_GAP*(N-1)))/2);

    // base
    ctx.save();
    ctx.globalAlpha=0.35;
    ctx.fillStyle="rgba(255,255,255,0.04)";
    roundedRect(startX-10,startY-10,cell*N+CELL_GAP*(N-1)+20,cell*N+CELL_GAP*(N-1)+20,22);
    ctx.fill();
    ctx.restore();

    // empty
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const px=startX+x*(cell+CELL_GAP);
        const py=startY+y*(cell+CELL_GAP);
        ctx.fillStyle="rgba(255,255,255,0.035)";
        ctx.beginPath();
        const rr=14;
        ctx.moveTo(px+rr,py);
        ctx.arcTo(px+cell,py,px+cell,py+cell,rr);
        ctx.arcTo(px+cell,py+cell,px,py+cell,rr);
        ctx.arcTo(px,py+cell,px,py,rr);
        ctx.arcTo(px,py,px+cell,py,rr);
        ctx.closePath();
        ctx.fill();
      }
    }

    // blocks
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const id=grid[y][x];
        if(id===null) continue;
        const [r,g,b]=COLORS[id]||[200,200,200];
        const px=startX+x*(cell+CELL_GAP);
        const py=startY+y*(cell+CELL_GAP);

        ctx.fillStyle=`rgba(${r},${g},${b},0.22)`;
        ctx.strokeStyle=`rgba(${r},${g},${b},0.50)`;
        ctx.lineWidth=3;

        ctx.beginPath();
        const rr=14;
        ctx.moveTo(px+rr,py);
        ctx.arcTo(px+cell,py,px+cell,py+cell,rr);
        ctx.arcTo(px+cell,py+cell,px,py+cell,rr);
        ctx.arcTo(px,py+cell,px,py,rr);
        ctx.arcTo(px,py,px+cell,py,rr);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    }

    // preview
    if(alive && hover){
      const cells=rotateCells(current.cells, rot);
      const ok=canPlaceAt(hover.x, hover.y);
      const [r,g,b]=COLORS[current.name]||[200,200,200];

      for(const [dx,dy] of cells){
        const x=hover.x+dx, y=hover.y+dy;
        const px=startX+x*(cell+CELL_GAP);
        const py=startY+y*(cell+CELL_GAP);

        ctx.fillStyle = ok ? `rgba(${r},${g},${b},0.16)` : "rgba(255,120,120,0.10)";
        ctx.strokeStyle = ok ? `rgba(${r},${g},${b},0.55)` : "rgba(255,120,120,0.35)";
        ctx.lineWidth = 3;

        ctx.beginPath();
        const rr=14;
        ctx.moveTo(px+rr,py);
        ctx.arcTo(px+cell,py,px+cell,py+cell,rr);
        ctx.arcTo(px+cell,py+cell,px,py+cell,rr);
        ctx.arcTo(px,py+cell,px,py,rr);
        ctx.arcTo(px,py,px+cell,py,rr);
        ctx.closePath();
        ctx.fill();
        ctx.setLineDash([8,8]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    ctx.fillStyle="rgba(231,238,252,0.72)";
    ctx.font="900 18px ui-sans-serif, system-ui";
    ctx.textAlign="left";
    ctx.textBaseline="top";
    ctx.fillText(`8×8 • Aftershock: ${nextShockDir()} (push ${AFTERSHOCK_PUSH}) • Score = clears only`, 18, 18);
  }

  function drawMini(){
    const W=mini.width,H=mini.height;
    mctx.clearRect(0,0,W,H);

    // background
    mctx.fillStyle="rgba(0,0,0,0.25)";
    mctx.fillRect(0,0,W,H);

    const cells = rotateCells(next.cells, 0);
    const b = bounds(cells);
    const pad = 18;
    const size = Math.min(W,H) - pad*2;
    const cell = Math.floor(size / Math.max(b.w, b.h));
    const ox = Math.floor((W - cell*b.w)/2);
    const oy = Math.floor((H - cell*b.h)/2);

    const [r,g,bb] = COLORS[next.name] || [200,200,200];
    mctx.fillStyle = `rgba(${r},${g},${bb},0.20)`;
    mctx.strokeStyle = `rgba(${r},${g},${bb},0.55)`;
    mctx.lineWidth = 3;

    for(const [x,y] of cells){
      const px = ox + x*cell;
      const py = oy + y*cell;
      const rr = Math.min(12, cell/3);
      mctx.beginPath();
      mctx.moveTo(px+rr,py);
      mctx.arcTo(px+cell,py,px+cell,py+cell,rr);
      mctx.arcTo(px+cell,py+cell,px,py+cell,rr);
      mctx.arcTo(px,py+cell,px,py,rr);
      mctx.arcTo(px,py,px+cell,py,rr);
      mctx.closePath();
      mctx.fill();
      mctx.stroke();
    }
  }

  function draw(){
    drawBoard();
    drawMini();
  }

  function updateUI(){
    scoreEl.textContent=String(score);
    movesEl.textContent=String(moves);
    chainEl.textContent=String(lastChain);
    shockEl.textContent=nextShockDir();

    curNameEl.textContent = current?.name ?? "—";
    nextNameEl.textContent = next?.name ?? "—";

    pieceInfoText();
    statusPill.textContent = alive ? "Alive" : "Dead";
    statusPill.style.borderColor = alive ? "rgba(72,211,138,.35)" : "rgba(255,204,102,.35)";
  }

  function pieceInfoText(){
    // keep minimal; names already shown
  }

  // Pointer mapping
  function canvasToCell(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX-rect.left) * (canvas.width/rect.width);
    const y = (clientY-rect.top) * (canvas.height/rect.height);

    const W=canvas.width,H=canvas.height;
    const gridSize=Math.min(W,H)-PAD*2;
    const cell=Math.floor((gridSize-(N-1)*CELL_GAP)/N);
    const startX=Math.floor((W-(cell*N+CELL_GAP*(N-1)))/2);
    const startY=Math.floor((H-(cell*N+CELL_GAP*(N-1)))/2);

    const gx=x-startX, gy=y-startY;
    if(gx<0||gy<0) return null;

    const step=cell+CELL_GAP;
    const cx=Math.floor(gx/step);
    const cy=Math.floor(gy/step);
    if(cx<0||cx>=N||cy<0||cy>=N) return null;
    return {x:cx,y:cy};
  }

  canvas.addEventListener('pointermove', (e)=>{
    hover = canvasToCell(e.clientX, e.clientY);
    draw();
  });
  canvas.addEventListener('pointerleave', ()=>{
    hover=null; draw();
  });
  canvas.addEventListener('pointerup', (e)=>{
    const cell = canvasToCell(e.clientX, e.clientY);
    if(cell){ hover=cell; place(cell.x, cell.y); }
  });

  window.addEventListener('keydown', (e)=>{
    if(e.key==='r'||e.key==='R'){ rot=(rot+1)%4; updateUI(); draw(); }
    if(e.key==='u'||e.key==='U'){ undo(); }
  });

  document.getElementById('newRun').addEventListener('click', reset);
  document.getElementById('undo').addEventListener('click', undo);

  // DPR handling
  function resizeForDPR(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
      draw();
    }

    // mini fixed but scale to DPR too
    const r2 = mini.getBoundingClientRect();
    const mw = Math.round(r2.width * dpr);
    const mh = Math.round(r2.height * dpr);
    if(mini.width !== mw || mini.height !== mh){
      mini.width = mw;
      mini.height = mh;
      drawMini();
    }
  }
  const ro = new ResizeObserver(resizeForDPR);
  ro.observe(canvas);
  ro.observe(mini);

  function reset(){
    grid = newGrid();
    score = 0;
    moves = 0;
    lastChain = 0;
    alive = true;
    history.length = 0;

    current = randChoice(PIECES);
    next = randChoice(PIECES);
    rot = 0;

    updateUI(); draw();
    showToast("Hard run");
  }

  reset();
  resizeForDPR();
})();
</script>
</body>
</html>
