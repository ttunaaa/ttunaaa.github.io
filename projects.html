<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Aftermath — Prototype v2 (Actually Makes Sense)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --stroke:rgba(255,255,255,.12);
      --ink:#e7eefc;
      --muted:#9fb0cc;
      --shadow: 0 16px 44px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(122,167,255,.18), transparent 55%),
        radial-gradient(900px 700px at 90% 10%, rgba(255,204,102,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding:18px 16px 22px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:16px;
      align-items:start;
    }
    header{
      grid-column:1 / -1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:14px 14px;
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
    }
    .brand{ display:flex; align-items:baseline; gap:10px; flex-wrap:wrap; }
    .brand h1{ margin:0; font-size:16px; letter-spacing:.3px; font-weight:800;}
    .brand .sub{ color:var(--muted); font-size:12px; }
    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    button{
      appearance:none;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--ink);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight:700;
      font-size: 13px;
    }
    button:hover{ background: rgba(255,255,255,.07); border-color: rgba(122,167,255,.35); }
    button:active{ transform: translateY(1px); }

    .stage{
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      padding:14px;
    }
    .topline{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px; margin-bottom:10px; flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background:#48d38a;
      box-shadow:0 0 0 3px rgba(72,211,138,.14);
    }
    .boardWrap{ display:flex; justify-content:center; align-items:center; }
    canvas{
      width: 100%;
      max-width: 640px;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.26);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      user-select:none;
      touch-action:none;
      display:block;
    }
    .sidebar{
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .card{
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      border-radius: 16px;
      padding: 12px;
    }
    .card h2{ margin:0 0 8px; font-size: 14px; letter-spacing:.2px; }
    .card p{ margin:0; color:var(--muted); font-size: 13px; line-height:1.45; }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .stat{
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .stat .label{ color:var(--muted); font-size:12px; }
    .stat .value{ font-size:18px; font-weight: 900; margin-top:2px; }
    .hint{
      border-top:1px solid var(--stroke);
      padding-top:12px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .kbd{
      display:inline-block;
      padding:1px 6px;
      border:1px solid var(--stroke);
      border-radius: 8px;
      background: rgba(255,255,255,.04);
      color: var(--ink);
      font-size: 12px;
      font-weight: 800;
      margin:0 2px;
    }
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.55);
      color: var(--ink);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      box-shadow: var(--shadow);
      z-index: 50;
      max-width: min(680px, calc(100vw - 32px));
      text-align:center;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-4px); }

    @media (max-width: 920px){
      .app{ grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <h1>Aftermath</h1>
        <div class="sub">place → gravity → aftershock → clears (score only from clears)</div>
      </div>
      <div class="row">
        <button id="newRun">New Run</button>
        <button id="undo">Undo</button>
      </div>
    </header>

    <section class="stage">
      <div class="topline">
        <div class="pill"><span class="dot"></span> Click/Tap to place • <b>R</b> rotate • <b>U</b> undo</div>
        <div class="pill" id="statusPill">Alive</div>
      </div>
      <div class="boardWrap">
        <canvas id="c" width="800" height="800"></canvas>
      </div>
    </section>

    <aside class="sidebar">
      <div class="card">
        <h2>Rules that make sense</h2>
        <p>
          You place a piece on a shaky platform.<br>
          After each placement: <b>Gravity</b> settles blocks, then an <b>Aftershock</b> pushes blocks 1 cell
          <b>← / →</b> alternating each move, then full rows clear.<br><br>
          <b>No points for placing.</b> Only clears + chains score. Spam placing will kill you.
        </p>
        <div class="stats">
          <div class="stat"><div class="label">Score</div><div class="value" id="score">0</div></div>
          <div class="stat"><div class="label">Moves</div><div class="value" id="moves">0</div></div>
          <div class="stat"><div class="label">Next Aftershock</div><div class="value" id="shock">←</div></div>
          <div class="stat"><div class="label">Chain</div><div class="value" id="chain">0</div></div>
        </div>
      </div>

      <div class="card">
        <h2>Current piece</h2>
        <p id="pieceInfo">—</p>
      </div>

      <div class="hint">
        Controls:
        <span class="kbd">Tap/Click</span> place,
        <span class="kbd">R</span> rotate,
        <span class="kbd">U</span> undo.<br><br>
        Strategy: plan for the <b>aftershock</b>. Sometimes you place “wrong” so the shake fixes it.
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const shockEl = document.getElementById('shock');
  const chainEl = document.getElementById('chain');
  const statusPill = document.getElementById('statusPill');
  const pieceInfo = document.getElementById('pieceInfo');
  const toastEl = document.getElementById('toast');

  const N = 10;               // grid size
  const CELL_GAP = 7;
  const PAD = 28;

  // Tetrominoes (relative cells)
  const PIECES = [
    { name: "I", cells: [[0,0],[1,0],[2,0],[3,0]] },
    { name: "O", cells: [[0,0],[1,0],[0,1],[1,1]] },
    { name: "T", cells: [[0,0],[1,0],[2,0],[1,1]] },
    { name: "L", cells: [[0,0],[0,1],[0,2],[1,2]] },
    { name: "J", cells: [[1,0],[1,1],[1,2],[0,2]] },
    { name: "S", cells: [[1,0],[2,0],[0,1],[1,1]] },
    { name: "Z", cells: [[0,0],[1,0],[1,1],[2,1]] },
  ];

  // Color per piece type
  const COLORS = {
    I: [122,167,255],
    O: [255,204,102],
    T: [178,122,255],
    L: [255,143,92],
    J: [72,211,138],
    S: [255,122,185],
    Z: [120,220,255],
  };

  let grid;
  let current;
  let rot = 0;
  let hover = null;          // {x,y}
  let alive = true;

  let score = 0;
  let moves = 0;
  let lastChain = 0;

  const history = [];

  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove('show'), 900);
  }

  function newGrid(){
    return Array.from({length:N}, () => Array(N).fill(null));
  }

  function copyGrid(g){
    return g.map(row => row.slice());
  }

  function randChoice(arr){ return arr[(Math.random()*arr.length)|0]; }

  function rotateCells(cells, r){
    // r in 0..3 about origin, normalize min x/y
    let out = cells.map(([x,y]) => [x,y]);
    for(let i=0;i<r;i++){
      out = out.map(([x,y]) => [y, -x]);
    }
    let minX = Infinity, minY = Infinity;
    for(const [x,y] of out){ minX = Math.min(minX,x); minY = Math.min(minY,y); }
    out = out.map(([x,y]) => [x-minX, y-minY]);
    return out;
  }

  function bounds(cells){
    let mx=0,my=0;
    for(const [x,y] of cells){ mx=Math.max(mx,x); my=Math.max(my,y); }
    return {w:mx+1,h:my+1};
  }

  function pushHistory(){
    history.push({
      grid: copyGrid(grid),
      current: JSON.parse(JSON.stringify(current)),
      rot, score, moves, lastChain, alive
    });
    if(history.length > 30) history.shift();
  }

  function undo(){
    const s = history.pop();
    if(!s) return;
    grid = copyGrid(s.grid);
    current = s.current;
    rot = s.rot;
    score = s.score;
    moves = s.moves;
    lastChain = s.lastChain;
    alive = s.alive;
    updateUI();
    draw();
    showToast("Undo");
  }

  function reroll(){
    current = randChoice(PIECES);
    rot = 0;
    updateUI();
    draw();
  }

  function nextShockDir(){
    // Alternate left/right each move. Clear and predictable.
    return (moves % 2 === 0) ? "←" : "→"; // because moves increments after placement
  }

  function canPlaceAt(x0, y0){
    const cells = rotateCells(current.cells, rot);
    for(const [dx,dy] of cells){
      const x = x0 + dx, y = y0 + dy;
      if(x<0||x>=N||y<0||y>=N) return false;
      if(grid[y][x] !== null) return false;
    }
    return true;
  }

  function hasAnyMove(){
    const piece = current;
    for(let r=0;r<4;r++){
      const cells = rotateCells(piece.cells, r);
      const b = bounds(cells);
      for(let y=0;y<=N-b.h;y++){
        for(let x=0;x<=N-b.w;x++){
          let ok = true;
          for(const [dx,dy] of cells){
            if(grid[y+dy][x+dx] !== null){ ok=false; break; }
          }
          if(ok) return true;
        }
      }
    }
    return false;
  }

  function place(x0,y0){
    if(!alive) return;
    if(!canPlaceAt(x0,y0)){
      showToast("Can't place");
      return;
    }

    pushHistory();

    const cells = rotateCells(current.cells, rot);
    for(const [dx,dy] of cells){
      grid[y0+dy][x0+dx] = current.name; // store piece id for color
    }

    // Run deterministic aftermath pipeline
    moves += 1;
    lastChain = runAftermath();

    // Next piece
    reroll();

    // Check death
    alive = hasAnyMove();
    updateUI();
    draw();

    if(!alive){
      statusPill.textContent = "Dead";
      statusPill.style.borderColor = "rgba(255,204,102,.35)";
      showToast("No legal moves");
    } else if(lastChain > 0){
      showToast(`Chain x${lastChain}`);
    } else {
      showToast("Placed");
    }
  }

  function applyGravity(){
    let moved = false;
    for(let x=0;x<N;x++){
      const stack = [];
      for(let y=N-1;y>=0;y--){
        const v = grid[y][x];
        if(v !== null) stack.push(v);
      }
      for(let y=N-1;y>=0;y--){
        const nv = stack[N-1-y] ?? null;
        if(grid[y][x] !== nv) moved = true;
        grid[y][x] = nv;
      }
    }
    return moved;
  }

  function aftershockPush(dir){
    // One-cell push in dir, but only into empty. Order matters to avoid double-moving.
    let moved = false;
    if(dir === "←"){
      for(let y=0;y<N;y++){
        for(let x=1;x<N;x++){
          if(grid[y][x] !== null && grid[y][x-1] === null){
            grid[y][x-1] = grid[y][x];
            grid[y][x] = null;
            moved = true;
          }
        }
      }
    } else if(dir === "→"){
      for(let y=0;y<N;y++){
        for(let x=N-2;x>=0;x--){
          if(grid[y][x] !== null && grid[y][x+1] === null){
            grid[y][x+1] = grid[y][x];
            grid[y][x] = null;
            moved = true;
          }
        }
      }
    }
    return moved;
  }

  function clearFullRows(){
    // Clears full rows, returns how many cleared.
    const keep = [];
    let cleared = 0;
    for(let y=0;y<N;y++){
      const full = grid[y].every(v => v !== null);
      if(full){
        cleared++;
      } else {
        keep.push(grid[y]);
      }
    }
    while(keep.length < N){
      keep.unshift(Array(N).fill(null));
    }
    grid = keep;
    return cleared;
  }

  function runAftermath(){
    // Pipeline: gravity -> aftershock -> clear -> gravity; repeat while clears happen (chains)
    let chain = 0;
    let dir = nextShockDir();
    shockEl.textContent = dir;

    // A single move can cause multiple clear cycles.
    while(true){
      applyGravity();
      aftershockPush(dir);

      const cleared = clearFullRows();
      if(cleared <= 0){
        // Settle once more for cleanliness (optional)
        applyGravity();
        break;
      }

      chain++;
      // Score only from clears (no placement points)
      // Reward chains and multi-clears
      const base = 200;
      const multi = cleared * cleared;             // 1->1, 2->4, 3->9...
      const chainMult = 1 + (chain - 1) * 0.7;     // escalating reward
      score += Math.floor(base * multi * chainMult);
    }

    return chain;
  }

  // ===== Drawing =====
  function tierColor(id){
    const rgb = COLORS[id] || [200,200,200];
    return rgb;
  }

  function roundedRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function draw(){
    const W = canvas.width;
    const H = canvas.height;
    ctx.clearRect(0,0,W,H);

    const gridSize = Math.min(W,H) - PAD*2;
    const cell = Math.floor((gridSize - (N-1)*CELL_GAP) / N);
    const startX = Math.floor((W - (cell*N + CELL_GAP*(N-1))) / 2);
    const startY = Math.floor((H - (cell*N + CELL_GAP*(N-1))) / 2);

    // faint base
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "rgba(255,255,255,0.04)";
    roundedRect(startX-10, startY-10, cell*N + CELL_GAP*(N-1) + 20, cell*N + CELL_GAP*(N-1) + 20, 22);
    ctx.fill();
    ctx.restore();

    // empty cells
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const px = startX + x*(cell + CELL_GAP);
        const py = startY + y*(cell + CELL_GAP);
        ctx.fillStyle = "rgba(255,255,255,0.035)";
        roundedRect(px,py,cell,cell,14);
        ctx.fill();
      }
    }

    // blocks
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const id = grid[y][x];
        if(id === null) continue;
        const [r,g,b] = tierColor(id);
        const px = startX + x*(cell + CELL_GAP);
        const py = startY + y*(cell + CELL_GAP);

        ctx.fillStyle = `rgba(${r},${g},${b},0.22)`;
        ctx.strokeStyle = `rgba(${r},${g},${b},0.45)`;
        ctx.lineWidth = 3;
        roundedRect(px,py,cell,cell,14);
        ctx.fill();
        ctx.stroke();
      }
    }

    // preview
    if(alive && hover){
      const cells = rotateCells(current.cells, rot);
      const ok = canPlaceAt(hover.x, hover.y);
      for(const [dx,dy] of cells){
        const x = hover.x + dx, y = hover.y + dy;
        const px = startX + x*(cell + CELL_GAP);
        const py = startY + y*(cell + CELL_GAP);

        const [r,g,b] = tierColor(current.name);
        ctx.fillStyle = ok ? `rgba(${r},${g},${b},0.16)` : "rgba(255,120,120,0.10)";
        ctx.strokeStyle = ok ? `rgba(${r},${g},${b},0.45)` : "rgba(255,120,120,0.35)";
        ctx.lineWidth = 3;
        roundedRect(px,py,cell,cell,14);
        ctx.fill();
        ctx.setLineDash([8,8]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // overlay text
    ctx.fillStyle = "rgba(231,238,252,0.70)";
    ctx.font = "800 18px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(`Aftershock next: ${nextShockDir()}   •   Score from clears only`, 18, 18);
  }

  function updateUI(){
    scoreEl.textContent = String(score);
    movesEl.textContent = String(moves);
    chainEl.textContent = String(lastChain);
    shockEl.textContent = nextShockDir();
    pieceInfo.textContent = `${current?.name ?? "—"} • rot ${rot*90}° • (place it knowing the shake is ${nextShockDir()})`;

    statusPill.textContent = alive ? "Alive" : "Dead";
    statusPill.style.borderColor = alive ? "rgba(72,211,138,.35)" : "rgba(255,204,102,.35)";
  }

  // ===== Pointer mapping =====
  function canvasToCell(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);

    const W = canvas.width;
    const H = canvas.height;
    const gridSize = Math.min(W,H) - PAD*2;
    const cell = Math.floor((gridSize - (N-1)*CELL_GAP) / N);
    const startX = Math.floor((W - (cell*N + CELL_GAP*(N-1))) / 2);
    const startY = Math.floor((H - (cell*N + CELL_GAP*(N-1))) / 2);

    const gx = x - startX;
    const gy = y - startY;
    if(gx < 0 || gy < 0) return null;

    const step = cell + CELL_GAP;
    const cx = Math.floor(gx / step);
    const cy = Math.floor(gy / step);
    if(cx < 0 || cx >= N || cy < 0 || cy >= N) return null;
    return {x:cx, y:cy};
  }

  canvas.addEventListener('pointermove', (e) => {
    hover = canvasToCell(e.clientX, e.clientY);
    draw();
  });

  canvas.addEventListener('pointerleave', () => {
    hover = null;
    draw();
  });

  canvas.addEventListener('pointerup', (e) => {
    const cell = canvasToCell(e.clientX, e.clientY);
    if(cell){
      hover = cell;
      place(cell.x, cell.y);
    }
  });

  // ===== Keyboard =====
  window.addEventListener('keydown', (e) => {
    if(e.key === 'r' || e.key === 'R'){
      rot = (rot + 1) % 4;
      updateUI(); draw();
    }
    if(e.key === 'u' || e.key === 'U'){
      undo();
    }
  });

  document.getElementById('newRun').addEventListener('click', () => reset());
  document.getElementById('undo').addEventListener('click', () => undo());

  function reset(){
    grid = newGrid();
    score = 0;
    moves = 0;
    lastChain = 0;
    alive = true;
    history.length = 0;
    reroll();
    updateUI();
    draw();
    showToast("New run");
  }

  // Crisp on resize (DPR)
  function resizeCanvasForDPR(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.round(rect.width * dpr);
    const h = Math.round(rect.height * dpr);
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w;
      canvas.height = h;
      draw();
    }
  }
  const ro = new ResizeObserver(resizeCanvasForDPR);
  ro.observe(canvas);

  reset();
  resizeCanvasForDPR();
})();
</script>
</body>
</html>
