<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Perfect Fit — HTML Mockup</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101826;
      --panel2:#0f1520;
      --ink:#e7eefc;
      --muted:#9fb0cc;
      --stroke:rgba(255,255,255,.12);
      --accent:#7aa7ff;
      --good:#48d38a;
      --warn:#ffcc66;
      --shadow: 0 14px 40px rgba(0,0,0,.45);
      --radius: 18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% -10%, rgba(122,167,255,.20), transparent 55%),
                  radial-gradient(900px 600px at 90% 10%, rgba(72,211,138,.12), transparent 55%),
                  var(--bg);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }

    .app{
      width:min(1020px, 100%);
      display:grid;
      grid-template-columns: 1.3fr .9fr;
      gap:18px;
    }

    header{
      grid-column: 1 / -1;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px 16px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
    }

    .brand{
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .brand h1{
      margin:0;
      font-size: 16px;
      letter-spacing:.4px;
      font-weight: 650;
    }
    .brand .sub{
      color:var(--muted);
      font-size:12px;
    }
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    button{
      appearance:none;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--ink);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight:600;
      font-size: 13px;
    }
    button:hover{ background: rgba(255,255,255,.07); border-color: rgba(122,167,255,.35); }
    button:active{ transform: translateY(1px); }

    .stage{
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      padding:16px;
      position:relative;
      min-height: 520px;
    }

    .stageTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 12px;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;background:var(--warn);
      box-shadow: 0 0 0 3px rgba(255,204,102,.15);
    }

    /* Board is a fixed coordinate plane to keep snapping simple */
    .board{
      position:relative;
      width: 100%;
      max-width: 620px;
      height: 420px;
      margin: 0 auto;
      border-radius: 20px;
      border:1px solid var(--stroke);
      background:
        radial-gradient(circle at 25% 15%, rgba(255,255,255,.06), transparent 55%),
        radial-gradient(circle at 90% 85%, rgba(122,167,255,.08), transparent 55%),
        rgba(0,0,0,.25);
      overflow:hidden;
      user-select:none;
      touch-action:none;
    }

    .hintGrid{
      position:absolute; inset:0;
      background-image:
        linear-gradient(to right, rgba(255,255,255,.04) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.04) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: .25;
      pointer-events:none;
    }

    .target{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      filter: drop-shadow(0 10px 30px rgba(0,0,0,.45));
    }

    /* Silhouette = "hole" look */
    .silhouette{
      width: 360px;
      height: 280px;
      border-radius: 26px;
      background:
        radial-gradient(circle at 30% 30%, rgba(0,0,0,.55), rgba(0,0,0,.75) 70%),
        rgba(0,0,0,.65);
      border:1px solid rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
    }
    .silhouette::before{
      content:"";
      position:absolute; inset:-40px;
      background: radial-gradient(circle at 35% 35%, rgba(122,167,255,.18), transparent 55%);
      opacity:.55;
      transform: rotate(-12deg);
    }

    /* The actual "cutout" is a shape mask; we approximate with an SVG path */
    .cutout{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:.95;
    }
    .cutout svg{
      width: 330px;
      height: 250px;
    }

    /* Pieces */
    .piece{
      position:absolute;
      width: 120px;
      height: 120px;
      cursor: grab;
      transform-origin: center;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,.45));
      transition: transform .12s ease, filter .12s ease;
    }
    .piece:active{ cursor: grabbing; filter: drop-shadow(0 14px 22px rgba(0,0,0,.55)); }
    .piece svg{ width:100%; height:100%; display:block; }
    .piece .outline{ stroke: rgba(255,255,255,.35); stroke-width: 2; fill: rgba(122,167,255,.18); }
    .piece[data-color="mint"] .outline{ fill: rgba(72,211,138,.18); }
    .piece[data-color="amber"] .outline{ fill: rgba(255,204,102,.18); }

    .ghost{
      position:absolute;
      width: 120px; height: 120px;
      pointer-events:none;
      opacity:.25;
      filter:none;
    }
    .ghost svg .outline{
      fill: rgba(255,255,255,.18);
      stroke: rgba(255,255,255,.20);
      stroke-dasharray: 6 6;
    }

    .sidebar{
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow: var(--shadow);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:14px;
      min-height: 520px;
    }

    .card{
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      border-radius: 16px;
      padding: 12px;
    }
    .card h2{
      margin:0 0 8px;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .card p{
      margin:0;
      color:var(--muted);
      font-size: 13px;
      line-height:1.45;
    }

    .statRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .stat{
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .stat .label{ color:var(--muted); font-size:12px; }
    .stat .value{ font-size:18px; font-weight: 750; margin-top:2px; }

    .footerTip{
      margin-top:auto;
      color:var(--muted);
      font-size:12px;
      border-top:1px solid var(--stroke);
      padding-top:12px;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.50);
      color: var(--ink);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      box-shadow: var(--shadow);
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
    }

    @media (max-width: 920px){
      .app{ grid-template-columns: 1fr; }
      .board{ max-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <h1>Perfect Fit</h1>
        <div class="sub">mockup — drag pieces into the silhouette</div>
      </div>
      <div class="controls">
        <button id="btnShuffle">New Puzzle</button>
        <button id="btnReset">Reset Pieces</button>
        <button id="btnHelp">Toggle Ghost</button>
      </div>
    </header>

    <section class="stage">
      <div class="stageTop">
        <div class="pill"><span class="dot"></span> Goal: place all 3 pieces. Snap into slots.</div>
        <div class="pill" id="statusPill">Not solved</div>
      </div>

      <div class="board" id="board">
        <div class="hintGrid"></div>

        <div class="target">
          <div class="silhouette">
            <div class="cutout">
              <!-- Decorative cutout shape -->
              <svg viewBox="0 0 330 250" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M52 127c0-36 26-68 61-78 20-6 31-21 52-30 22-10 54-8 74 6 16 11 20 28 35 40 21 17 44 15 50 48 8 44-21 86-64 98-18 5-29 17-46 25-23 12-55 12-79 0-17-8-27-24-45-27-40-7-38-42-38-82z"
                      fill="rgba(0,0,0,.70)" stroke="rgba(255,255,255,.10)" stroke-width="2"/>
                <path d="M88 122c0-22 15-40 36-46 14-4 21-13 34-19 16-7 37-5 51 4 10 7 12 18 22 26 14 11 29 10 33 30 5 26-12 52-38 59-11 3-17 10-27 15-15 8-38 8-54 0-10-5-17-15-29-17-24-4-28-20-28-52z"
                      fill="rgba(0,0,0,.88)"/>
              </svg>
            </div>
          </div>
        </div>

        <!-- Ghost slots -->
        <div class="ghost" id="ghostA"></div>
        <div class="ghost" id="ghostB"></div>
        <div class="ghost" id="ghostC"></div>

        <!-- Pieces -->
        <div class="piece" id="pieceA" data-slot="A" data-color="blue" style="left:36px; top:282px;">
          <svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
            <path class="outline" d="M18 78 L18 34 Q18 24 28 24 L70 24 Q80 24 80 34 L80 52 L98 52 Q108 52 108 62 L108 96 Q108 106 98 106 L34 106 Q18 106 18 90 Z"/>
          </svg>
        </div>

        <div class="piece" id="pieceB" data-slot="B" data-color="mint" style="left:166px; top:298px;">
          <svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
            <path class="outline" d="M22 26 H86 Q98 26 98 38 V54 Q98 62 90 62 H74 V94 Q74 106 62 106 H34 Q22 106 22 94 Z"/>
          </svg>
        </div>

        <div class="piece" id="pieceC" data-slot="C" data-color="amber" style="left:294px; top:288px;">
          <svg viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg">
            <path class="outline" d="M18 38 Q18 26 30 26 H54 Q66 26 66 38 V52 H92 Q104 52 104 64 V92 Q104 104 92 104 H30 Q18 104 18 92 Z"/>
          </svg>
        </div>

      </div>
    </section>

    <aside class="sidebar">
      <div class="card">
        <h2>How it plays (mock)</h2>
        <p>
          Drag each piece onto its hidden slot. When you get close enough, it snaps in.
          This is the core “satisfaction” loop — in the real game you’d have different silhouettes every round.
        </p>

        <div class="statRow">
          <div class="stat">
            <div class="label">Placed</div>
            <div class="value"><span id="placedCount">0</span>/3</div>
          </div>
          <div class="stat">
            <div class="label">Moves</div>
            <div class="value" id="moveCount">0</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>What would make it “blow up”</h2>
        <p>
          Daily seed puzzle + instant share replays + absurdly satisfying snap audio + no tutorial.
          Keep sessions ~20–40 seconds.
        </p>
      </div>

      <div class="footerTip">
        Tip: In a real build, the “warping silhouette” mechanic can be done by slightly shifting slot targets after a bad placement.
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ===== "Perfect Fit" Mockup Logic =====
    // This is intentionally minimal: drag pieces, snap to target slots, detect solved.
    // Slots are defined in board coordinates.

    const board = document.getElementById("board");
    const toast = document.getElementById("toast");
    const statusPill = document.getElementById("statusPill");
    const placedCountEl = document.getElementById("placedCount");
    const moveCountEl = document.getElementById("moveCount");

    const pieces = [
      document.getElementById("pieceA"),
      document.getElementById("pieceB"),
      document.getElementById("pieceC"),
    ];

    const ghosts = {
      A: document.getElementById("ghostA"),
      B: document.getElementById("ghostB"),
      C: document.getElementById("ghostC"),
    };

    // Slot positions (top-left of piece) relative to board
    // Chosen to land over the silhouette area.
    let slots = {
      A: { x: 170, y: 125 },
      B: { x: 240, y: 150 },
      C: { x: 120, y: 155 },
    };

    // Optional: slight randomized warp for "New Puzzle"
    function jitterSlots() {
      // Keep within silhouette-ish range
      const j = (n) => n + Math.round((Math.random() - 0.5) * 40); // +/-20px
      slots = {
        A: { x: j(170), y: j(125) },
        B: { x: j(240), y: j(150) },
        C: { x: j(120), y: j(155) },
      };
    }

    // Starting positions (top-left) for reset
    const startPos = new Map();

    let showGhost = true;
    let moveCount = 0;

    function showToast(msg) {
      toast.textContent = msg;
      toast.classList.add("show");
      window.clearTimeout(showToast._t);
      showToast._t = window.setTimeout(() => toast.classList.remove("show"), 900);
    }

    function boardRect() {
      return board.getBoundingClientRect();
    }

    function setPiecePos(el, x, y) {
      el.style.left = `${x}px`;
      el.style.top = `${y}px`;
    }

    function getPiecePos(el) {
      return {
        x: parseFloat(el.style.left || "0"),
        y: parseFloat(el.style.top || "0")
      };
    }

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function renderGhosts() {
      for (const [key, ghost] of Object.entries(ghosts)) {
        const s = slots[key];
        ghost.style.left = s.x + "px";
        ghost.style.top = s.y + "px";
        ghost.style.display = showGhost ? "block" : "none";
        ghost.innerHTML = pieces.find(p => p.dataset.slot === key).innerHTML;
      }
    }

    function updateUI() {
      const placed = pieces.filter(p => p.dataset.placed === "true").length;
      placedCountEl.textContent = String(placed);
      moveCountEl.textContent = String(moveCount);

      if (placed === 3) {
        statusPill.textContent = "Solved ✔";
        statusPill.style.borderColor = "rgba(72,211,138,.35)";
        statusPill.style.color = "rgba(231,238,252,1)";
        showToast("Perfect fit!");
      } else {
        statusPill.textContent = "Not solved";
        statusPill.style.borderColor = "var(--stroke)";
        statusPill.style.color = "var(--muted)";
      }
    }

    function clampToBoard(x, y, w, h) {
      // Ensure piece stays within board bounds
      const maxX = board.clientWidth - w;
      const maxY = board.clientHeight - h;
      return {
        x: Math.max(0, Math.min(maxX, x)),
        y: Math.max(0, Math.min(maxY, y)),
      };
    }

    function snapIfClose(piece) {
      const slotKey = piece.dataset.slot;
      const target = slots[slotKey];
      const pos = getPiecePos(piece);

      // Snap threshold
      const snapRadius = 22;

      if (distance(pos, target) <= snapRadius) {
        setPiecePos(piece, target.x, target.y);
        piece.dataset.placed = "true";
        piece.style.filter = "drop-shadow(0 14px 22px rgba(0,0,0,.55))";
        showToast("Snapped!");
      } else {
        piece.dataset.placed = "false";
      }
    }

    // Dragging via pointer events
    function enableDragging(piece) {
      const rect = () => piece.getBoundingClientRect();
      let dragging = false;
      let offsetX = 0;
      let offsetY = 0;

      piece.addEventListener("pointerdown", (e) => {
        piece.setPointerCapture(e.pointerId);
        dragging = true;

        const b = boardRect();
        const r = rect();

        // offset between pointer and piece top-left, in board coordinates
        offsetX = e.clientX - r.left;
        offsetY = e.clientY - r.top;

        // Bring to top
        piece.style.zIndex = 10;
      });

      piece.addEventListener("pointermove", (e) => {
        if (!dragging) return;

        const b = boardRect();
        const w = piece.offsetWidth;
        const h = piece.offsetHeight;

        let x = (e.clientX - b.left) - offsetX;
        let y = (e.clientY - b.top) - offsetY;

        const clamped = clampToBoard(x, y, w, h);
        setPiecePos(piece, clamped.x, clamped.y);
      });

      piece.addEventListener("pointerup", () => {
        if (!dragging) return;
        dragging = false;
        piece.style.zIndex = 3;

        moveCount += 1;
        snapIfClose(piece);
        updateUI();
      });

      piece.addEventListener("pointercancel", () => {
        dragging = false;
        piece.style.zIndex = 3;
      });
    }

    function resetPieces() {
      for (const p of pieces) {
        const s = startPos.get(p.id);
        setPiecePos(p, s.x, s.y);
        p.dataset.placed = "false";
        p.style.zIndex = 3;
      }
      moveCount = 0;
      updateUI();
    }

    function newPuzzle() {
      jitterSlots();
      renderGhosts();

      // Move pieces to randomized start positions on bottom area
      const baseY = 285;
      const xs = [40, 170, 300].map(v => v + Math.round((Math.random()-0.5)*18));
      pieces.forEach((p, i) => {
        setPiecePos(p, xs[i], baseY + Math.round((Math.random()-0.5)*18));
        p.dataset.placed = "false";
      });

      moveCount = 0;
      updateUI();
      showToast("New puzzle");
    }

    // Init
    pieces.forEach(p => {
      startPos.set(p.id, getPiecePos(p));
      enableDragging(p);
      p.dataset.placed = "false";
      p.style.zIndex = 3;
    });

    renderGhosts();
    updateUI();

    // Buttons
    document.getElementById("btnReset").addEventListener("click", () => {
      resetPieces();
      showToast("Reset");
    });

    document.getElementById("btnShuffle").addEventListener("click", () => {
      newPuzzle();
    });

    document.getElementById("btnHelp").addEventListener("click", () => {
      showGhost = !showGhost;
      renderGhosts();
      showToast(showGhost ? "Ghost on" : "Ghost off");
    });
  </script>
</body>
</html>
