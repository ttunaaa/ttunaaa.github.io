```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Aftermath — Premise 3 Prototype</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#101826;
      --stroke:rgba(255,255,255,.12);
      --ink:#e7eefc;
      --muted:#9fb0cc;
      --shadow: 0 16px 44px rgba(0,0,0,.45);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(122,167,255,.18), transparent 55%),
        radial-gradient(900px 700px at 90% 10%, rgba(72,211,138,.10), transparent 60%),
        var(--bg);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding:18px 16px 22px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:16px;
      align-items:start;
    }
    header{
      grid-column:1 / -1;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding:14px 14px;
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
    }
    .brand{
      display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;
    }
    .brand h1{ margin:0; font-size:16px; letter-spacing:.3px; font-weight:750;}
    .brand .sub{ color:var(--muted); font-size:12px; }
    .row{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }
    button, select{
      appearance:none;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--ink);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      font-weight:650;
      font-size: 13px;
    }
    button:hover, select:hover{ background: rgba(255,255,255,.07); border-color: rgba(122,167,255,.35); }
    button:active{ transform: translateY(1px); }
    .stage{
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      padding:14px;
      position:relative;
    }
    .topline{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px; margin-bottom:10px; flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background:#ffcc66;
      box-shadow:0 0 0 3px rgba(255,204,102,.14);
    }
    .boardWrap{
      display:flex; justify-content:center; align-items:center;
    }
    canvas{
      width: 100%;
      max-width: 640px;
      aspect-ratio: 1 / 1;
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.26);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      user-select:none;
      touch-action:none;
      display:block;
    }
    .sidebar{
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      box-shadow:var(--shadow);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height: 520px;
    }
    .card{
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      border-radius: 16px;
      padding: 12px;
    }
    .card h2{
      margin:0 0 8px;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .card p{
      margin:0;
      color:var(--muted);
      font-size: 13px;
      line-height:1.45;
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .stat{
      border:1px solid var(--stroke);
      border-radius: 14px;
      padding:10px;
      background: rgba(255,255,255,.03);
    }
    .stat .label{ color:var(--muted); font-size:12px; }
    .stat .value{ font-size:18px; font-weight: 800; margin-top:2px; }
    .hint{
      margin-top:auto;
      border-top:1px solid var(--stroke);
      padding-top:12px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .kbd{
      display:inline-block;
      padding:1px 6px;
      border:1px solid var(--stroke);
      border-bottom-color: rgba(255,255,255,.20);
      border-radius: 8px;
      background: rgba(255,255,255,.04);
      color: var(--ink);
      font-size: 12px;
      font-weight: 700;
      margin:0 2px;
    }
    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.55);
      color: var(--ink);
      font-size: 13px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      box-shadow: var(--shadow);
      z-index: 50;
      max-width: min(680px, calc(100vw - 32px));
      text-align:center;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.show{
      opacity: 1;
      transform: translateX(-50%) translateY(-4px);
    }
    @media (max-width: 920px){
      .app{ grid-template-columns: 1fr; }
      .sidebar{ min-height: unset; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <h1>Aftermath</h1>
        <div class="sub">place a piece → the system reacts</div>
      </div>
      <div class="row">
        <select id="mode">
          <option value="slideLR">Reaction: Slide L↔R + Gravity</option>
          <option value="slideToCenter">Reaction: Slide to Center + Gravity</option>
          <option value="wind">Reaction: Wind + Gravity</option>
        </select>
        <button id="newRun">New Run</button>
        <button id="undo">Undo</button>
        <button id="reset">Reset</button>
      </div>
    </header>

    <section class="stage">
      <div class="topline">
        <div class="pill"><span class="dot"></span> Tap/Click to place. <b>R</b> rotate, <b>Space</b> reroll piece.</div>
        <div class="pill" id="statusPill">Alive</div>
      </div>
      <div class="boardWrap">
        <canvas id="c" width="800" height="800" aria-label="Aftermath board"></canvas>
      </div>
    </section>

    <aside class="sidebar">
      <div class="card">
        <h2>Premise</h2>
        <p>
          You choose <b>where</b> to place a piece. You don’t choose what happens next.
          After placement, the board <b>reacts</b> (gravity + sliding + merges).
        </p>
        <div class="stats">
          <div class="stat">
            <div class="label">Score</div>
            <div class="value" id="score">0</div>
          </div>
          <div class="stat">
            <div class="label">Moves</div>
            <div class="value" id="moves">0</div>
          </div>
          <div class="stat">
            <div class="label">Chain</div>
            <div class="value" id="chain">0</div>
          </div>
          <div class="stat">
            <div class="label">Filled</div>
            <div class="value"><span id="filled">0</span>%</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>Current piece</h2>
        <p id="pieceInfo">—</p>
      </div>

      <div class="hint">
        Controls:
        <span class="kbd">Tap/Click</span> place,
        <span class="kbd">R</span> rotate,
        <span class="kbd">Space</span> reroll,
        <span class="kbd">U</span> undo.<br><br>
        Tip: This game becomes interesting when you stop optimizing for <i>now</i> and start fearing what the board will do <i>after</i>.
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ============================================================
    // AFTERMATH — A viral-ish prototype (Premise 3)
    //
    // Core:
    // 1) Place a piece (polyomino-ish).
    // 2) System reacts: gravity + a sliding rule.
    // 3) Merge rule creates emergent combos:
    //    - Any connected group of >= 4 same "tier" merges:
    //      one block upgrades (tier+1) at group's centroid; others vanish.
    //    - Upgraded blocks are valuable and can chain.
    //
    // Notes:
    // - All rules are consistent. Surprise comes from interactions.
    // - It’s intended to “fight back” without randomness in the reactions.
    // ============================================================

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const movesEl = document.getElementById('moves');
    const chainEl = document.getElementById('chain');
    const filledEl = document.getElementById('filled');
    const statusPill = document.getElementById('statusPill');
    const toastEl = document.getElementById('toast');
    const modeSel = document.getElementById('mode');
    const pieceInfo = document.getElementById('pieceInfo');

    // Board config
    const N = 12;               // grid size
    const MAX_TIER = 6;         // 1..6
    const CELL_GAP = 6;         // px gap (visual)
    const PAD = 26;             // px padding around grid (visual)

    // Reaction config
    const MERGE_MIN = 4;        // group size to merge
    const WIND_STRENGTH = 1;    // cells to push per reaction tick (wind mode)

    // Piece config
    const PIECE_BANK = [
      // Coordinates are relative cells (x,y) from origin (0,0).
      // Keep them small to allow fast turns.
      { name: "Mono", cells: [[0,0]] },
      { name: "Domino", cells: [[0,0],[1,0]] },
      { name: "L3", cells: [[0,0],[0,1],[1,1]] },
      { name: "I3", cells: [[0,0],[1,0],[2,0]] },
      { name: "T4", cells: [[0,0],[1,0],[2,0],[1,1]] },
      { name: "S4", cells: [[1,0],[2,0],[0,1],[1,1]] },
      { name: "Box4", cells: [[0,0],[1,0],[0,1],[1,1]] },
      { name: "L4", cells: [[0,0],[0,1],[0,2],[1,2]] },
      { name: "I4", cells: [[0,0],[1,0],[2,0],[3,0]] },
    ];

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 1000);
    }

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

    // State
    let grid;               // grid[y][x] = 0 empty or tier (1..MAX_TIER)
    let currentPiece;       // {name,cells}
    let pieceRot = 0;       // 0..3
    let placeTier = 1;      // tier for new placed blocks
    let hoverCell = null;   // {x,y}
    let score = 0;
    let moves = 0;
    let chain = 0;
    let alive = true;

    // Undo history (snapshot small, so OK)
    const history = [];

    function newEmptyGrid(){
      const g = [];
      for(let y=0;y<N;y++){
        const row = new Array(N).fill(0);
        g.push(row);
      }
      return g;
    }

    function deepCopyGrid(g){
      return g.map(row => row.slice());
    }

    function pushHistory(){
      history.push({
        grid: deepCopyGrid(grid),
        currentPiece: JSON.parse(JSON.stringify(currentPiece)),
        pieceRot,
        placeTier,
        score, moves, chain, alive
      });
      // Keep history bounded
      if(history.length > 40) history.shift();
    }

    function popHistory(){
      if(history.length === 0) return;
      const s = history.pop();
      grid = deepCopyGrid(s.grid);
      currentPiece = s.currentPiece;
      pieceRot = s.pieceRot;
      placeTier = s.placeTier;
      score = s.score;
      moves = s.moves;
      chain = s.chain;
      alive = s.alive;
      updateUI();
      draw();
      showToast("Undo");
    }

    function randChoice(arr){ return arr[(Math.random()*arr.length)|0]; }

    function rotateCells(cells, rot){
      // rot: 0,1,2,3 => 0°, 90°, 180°, 270° about origin
      // then normalized so min x,y = 0
      let out = cells.map(([x,y])=>[x,y]);
      for(let r=0;r<rot;r++){
        out = out.map(([x,y])=>[y, -x]);
      }
      // normalize
      let minX = Infinity, minY = Infinity;
      for(const [x,y] of out){
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      }
      out = out.map(([x,y])=>[x - minX, y - minY]);
      return out;
    }

    function pieceBounds(cells){
      let maxX=0, maxY=0;
      for(const [x,y] of cells){
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      return {w: maxX+1, h:maxY+1};
    }

    function rerollPiece(){
      currentPiece = randChoice(PIECE_BANK);
      pieceRot = 0;
      // place tier slowly increases with score
      placeTier = 1 + Math.min(MAX_TIER-1, Math.floor(score / 900));
      updateUI();
      draw();
    }

    function resetRun(){
      grid = newEmptyGrid();
      score = 0;
      moves = 0;
      chain = 0;
      alive = true;
      history.length = 0;
      rerollPiece();
      updateUI();
      draw();
      showToast("New run");
    }

    // ====== Placement checks ======
    function canPlaceAt(cellX, cellY){
      const cells = rotateCells(currentPiece.cells, pieceRot);
      for(const [dx,dy] of cells){
        const x = cellX + dx;
        const y = cellY + dy;
        if(x < 0 || x >= N || y < 0 || y >= N) return false;
        if(grid[y][x] !== 0) return false;
      }
      return true;
    }

    function placeAt(cellX, cellY){
      if(!alive) return;
      if(!canPlaceAt(cellX, cellY)){
        showToast("Can't place");
        return;
      }

      pushHistory();

      const cells = rotateCells(currentPiece.cells, pieceRot);
      for(const [dx,dy] of cells){
        grid[cellY + dy][cellX + dx] = placeTier;
      }
      moves += 1;

      // System reaction phase (deterministic given current mode)
      const mode = modeSel.value;

      chain = 0;
      let totalGained = 0;
      let reacted = true;

      // Reaction loop: apply physics then merges; repeat until stable.
      // (This is where the "Aftermath" feeling comes from.)
      let guard = 0;
      while(reacted && guard < 30){
        guard++;
        reacted = false;

        // 1) Apply gravity
        if(applyGravity()){
          reacted = true;
        }

        // 2) Apply slide / wind
        if(mode === "slideLR"){
          if(applySlideLR()){ reacted = true; }
        } else if(mode === "slideToCenter"){
          if(applySlideToCenter()){ reacted = true; }
        } else if(mode === "wind"){
          if(applyWind()){ reacted = true; }
        }

        // 3) Merges
        const mergeResult = applyMerges();
        if(mergeResult.didMerge){
          reacted = true;
          chain += 1;
          totalGained += mergeResult.scoreGained;
        }
      }

      // Score from placement is tiny; score from aftermath is the point.
      score += Math.floor(placeTier * 8);
      score += totalGained;

      // Reroll next piece
      rerollPiece();

      // Check end condition: no legal placements anywhere for current piece (and any rotation)
      alive = hasAnyLegalMove();
      updateUI();
      draw();

      if(chain > 0){
        showToast(`Chain x${chain}! +${totalGained}`);
      } else {
        showToast("Placed");
      }

      if(!alive){
        statusPill.textContent = "Dead";
        statusPill.style.borderColor = "rgba(255,204,102,.35)";
        statusPill.style.color = "rgba(231,238,252,1)";
        showToast("No moves left");
      }
    }

    function hasAnyLegalMove(){
      const piece = currentPiece;
      for(let rot=0; rot<4; rot++){
        const cells = rotateCells(piece.cells, rot);
        // rough bounds scan
        const b = pieceBounds(cells);
        for(let y=0; y<=N-b.h; y++){
          for(let x=0; x<=N-b.w; x++){
            let ok = true;
            for(const [dx,dy] of cells){
              if(grid[y+dy][x+dx] !== 0){ ok = false; break; }
            }
            if(ok) return true;
          }
        }
      }
      return false;
    }

    // ====== Physics rules ======
    function applyGravity(){
      // Blocks fall straight down if empty below. Column-wise collapse.
      let moved = false;
      for(let x=0;x<N;x++){
        // collect nonzero from bottom-up
        const stack = [];
        for(let y=N-1;y>=0;y--){
          if(grid[y][x] !== 0) stack.push(grid[y][x]);
        }
        // rewrite column
        for(let y=N-1;y>=0;y--){
          const v = stack[N-1-y] ?? 0;
          if(grid[y][x] !== v) moved = true;
          grid[y][x] = v;
        }
      }
      return moved;
    }

    function applySlideLR(){
      // Deterministic alternation based on moves:
      // odd move => slide left; even move => slide right
      const dir = (moves % 2 === 1) ? -1 : 1;
      let moved = false;

      for(let y=0;y<N;y++){
        const row = grid[y];
        const items = row.filter(v => v !== 0);
        const zeros = new Array(N - items.length).fill(0);
        const newRow = (dir === -1) ? items.concat(zeros) : zeros.concat(items);
        for(let x=0;x<N;x++){
          if(row[x] !== newRow[x]) moved = true;
          row[x] = newRow[x];
        }
      }
      return moved;
    }

    function applySlideToCenter(){
      // Each row collapses toward center columns (like magnets).
      let moved = false;
      const centerL = Math.floor((N-1)/2);
      const centerR = Math.ceil((N-1)/2);

      for(let y=0;y<N;y++){
        const row = grid[y];
        const items = row.filter(v=>v!==0);

        // build empty
        const newRow = new Array(N).fill(0);

        // place alternating around center
        let left = centerL;
        let right = centerR;
        let toggle = true; // start left-ish
        for(const v of items){
          if(toggle){
            newRow[left] = v;
            left--;
          } else {
            newRow[right] = v;
            right++;
          }
          toggle = !toggle;
          // If overflow, keep pushing outward
          left = clamp(left, 0, N-1);
          right = clamp(right, 0, N-1);
        }

        for(let x=0;x<N;x++){
          if(row[x] !== newRow[x]) moved = true;
          row[x] = newRow[x];
        }
      }
      return moved;
    }

    function applyWind(){
      // Wind direction depends on (moves mod 4):
      // 1: push left, 2: push up, 3: push right, 0: push down (then gravity will also act).
      // Wind is "one-cell shove" repeated WIND_STRENGTH times.
      let movedAny = false;
      const phase = moves % 4;
      for(let k=0;k<WIND_STRENGTH;k++){
        let moved = false;
        if(phase === 1){
          // push left: each row shift-left if empty exists to left of a block
          for(let y=0;y<N;y++){
            for(let x=1;x<N;x++){
              if(grid[y][x]!==0 && grid[y][x-1]===0){
                grid[y][x-1]=grid[y][x]; grid[y][x]=0; moved=true;
              }
            }
          }
        } else if(phase === 2){
          // push up: each col shift-up similarly
          for(let x=0;x<N;x++){
            for(let y=1;y<N;y++){
              if(grid[y][x]!==0 && grid[y-1][x]===0){
                grid[y-1][x]=grid[y][x]; grid[y][x]=0; moved=true;
              }
            }
          }
        } else if(phase === 3){
          // push right
          for(let y=0;y<N;y++){
            for(let x=N-2;x>=0;x--){
              if(grid[y][x]!==0 && grid[y][x+1]===0){
                grid[y][x+1]=grid[y][x]; grid[y][x]=0; moved=true;
              }
            }
          }
        } else {
          // push down (a little redundant with gravity but creates timing)
          for(let x=0;x<N;x++){
            for(let y=N-2;y>=0;y--){
              if(grid[y][x]!==0 && grid[y+1][x]===0){
                grid[y+1][x]=grid[y][x]; grid[y][x]=0; moved=true;
              }
            }
          }
        }
        if(moved) movedAny = true;
      }
      return movedAny;
    }

    // ====== Merge rule ======
    function applyMerges(){
      // Find connected components of same tier (4-neighbor).
      // Any component with size >= MERGE_MIN merges:
      // - Choose merge cell near centroid, preferring lower row (to "drop" feeling).
      // - Remove all cells in component.
      // - Place upgraded tier at merge cell (tier+1 capped).
      // Score gained scales nonlinearly.
      const visited = Array.from({length:N}, ()=>new Array(N).fill(false));
      let didMerge = false;
      let scoreGained = 0;

      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

      function bfs(sx, sy, tier){
        const q = [[sx,sy]];
        visited[sy][sx] = true;
        const cells = [[sx,sy]];
        while(q.length){
          const [x,y] = q.pop();
          for(const [dx,dy] of dirs){
            const nx=x+dx, ny=y+dy;
            if(nx<0||nx>=N||ny<0||ny>=N) continue;
            if(visited[ny][nx]) continue;
            if(grid[ny][nx] !== tier) continue;
            visited[ny][nx] = true;
            q.push([nx,ny]);
            cells.push([nx,ny]);
          }
        }
        return cells;
      }

      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const tier = grid[y][x];
          if(tier === 0 || visited[y][x]) continue;

          const comp = bfs(x,y,tier);
          if(comp.length >= MERGE_MIN){
            didMerge = true;

            // pick merge location: centroid then snap to a cell in comp
            let cx=0, cy=0;
            for(const [px,py] of comp){ cx+=px; cy+=py; }
            cx /= comp.length; cy /= comp.length;

            // choose comp cell closest to centroid; tie-break by larger y (lower)
            let best = comp[0];
            let bestD = Infinity;
            for(const [px,py] of comp){
              const d = (px-cx)*(px-cx) + (py-cy)*(py-cy);
              if(d < bestD - 1e-9 || (Math.abs(d-bestD)<1e-9 && py > best[1])){
                bestD = d;
                best = [px,py];
              }
            }

            // clear component
            for(const [px,py] of comp){
              grid[py][px] = 0;
            }

            // place upgraded block
            const nt = Math.min(MAX_TIER, tier + 1);
            grid[best[1]][best[0]] = nt;

            // score
            // Reward bigger comps and higher tiers (but keep bounded).
            const base = 40 * tier;
            const sizeBonus = (comp.length - (MERGE_MIN-1)) * 35 * tier;
            const tierBonus = Math.pow(2, tier) * 6;
            scoreGained += Math.floor(base + sizeBonus + tierBonus);
          }
        }
      }

      return { didMerge, scoreGained };
    }

    // ====== Rendering ======
    function tierColor(t){
      // Soft candy palette, deterministic, no CSS variables needed
      const palette = [
        null,
        [122,167,255], // tier 1
        [72,211,138],  // tier 2
        [255,204,102], // tier 3
        [255,122,185], // tier 4
        [178,122,255], // tier 5
        [255,143,92],  // tier 6
      ];
      return palette[t] || [200,200,200];
    }

    function roundedRect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function draw(){
      const W = canvas.width;
      const H = canvas.height;
      ctx.clearRect(0,0,W,H);

      // Compute cell size
      const gridSize = Math.min(W, H) - PAD*2;
      const cell = Math.floor((gridSize - (N-1)*CELL_GAP) / N);
      const startX = Math.floor((W - (cell*N + CELL_GAP*(N-1))) / 2);
      const startY = Math.floor((H - (cell*N + CELL_GAP*(N-1))) / 2);

      // Backplate subtle
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      roundedRect(startX-10, startY-10, cell*N + CELL_GAP*(N-1) + 20, cell*N + CELL_GAP*(N-1) + 20, 22);
      ctx.fill();
      ctx.restore();

      // Draw empty grid faint
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const px = startX + x*(cell + CELL_GAP);
          const py = startY + y*(cell + CELL_GAP);
          ctx.fillStyle = "rgba(255,255,255,0.035)";
          roundedRect(px,py,cell,cell,14);
          ctx.fill();
        }
      }

      // Draw blocks
      for(let y=0;y<N;y++){
        for(let x=0;x<N;x++){
          const t = grid[y][x];
          if(t===0) continue;
          const [r,g,b] = tierColor(t);
          const px = startX + x*(cell + CELL_GAP);
          const py = startY + y*(cell + CELL_GAP);

          // Fill
          ctx.fillStyle = `rgba(${r},${g},${b},0.22)`;
          ctx.strokeStyle = `rgba(${r},${g},${b},0.45)`;
          ctx.lineWidth = 3;
          roundedRect(px,py,cell,cell,14);
          ctx.fill();
          ctx.stroke();

          // inner sheen
          ctx.save();
          ctx.globalAlpha = 0.20;
          ctx.fillStyle = `rgba(255,255,255,0.60)`;
          roundedRect(px+6,py+6,cell-12,(cell-12)*0.42,12);
          ctx.fill();
          ctx.restore();

          // Tier number
          ctx.fillStyle = "rgba(231,238,252,0.85)";
          ctx.font = `800 ${Math.floor(cell*0.34)}px ui-sans-serif, system-ui, -apple-system`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(String(t), px + cell/2, py + cell/2 + 1);
        }
      }

      // Draw hover placement preview
      if(alive && hoverCell){
        const baseX = hoverCell.x;
        const baseY = hoverCell.y;
        const cells = rotateCells(currentPiece.cells, pieceRot);
        const ok = canPlaceAt(baseX, baseY);
        for(const [dx,dy] of cells){
          const x = baseX + dx;
          const y = baseY + dy;
          const px = startX + x*(cell + CELL_GAP);
          const py = startY + y*(cell + CELL_GAP);

          const [r,g,b] = tierColor(placeTier);
          ctx.fillStyle = ok ? `rgba(${r},${g},${b},0.18)` : "rgba(255,120,120,0.10)";
          ctx.strokeStyle = ok ? `rgba(${r},${g},${b},0.40)` : "rgba(255,120,120,0.35)";
          ctx.lineWidth = 3;
          roundedRect(px,py,cell,cell,14);
          ctx.fill();
          ctx.setLineDash([8,8]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      // Info text overlay (tiny)
      ctx.fillStyle = "rgba(231,238,252,0.65)";
      ctx.font = "700 18px ui-sans-serif, system-ui";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText(`Piece: ${currentPiece?.name ?? "—"}  •  Tier: ${placeTier}  •  Rot: ${pieceRot*90}°`, 18, 18);
    }

    // ====== UI ======
    function updateUI(){
      scoreEl.textContent = String(score);
      movesEl.textContent = String(moves);
      chainEl.textContent = String(chain);

      // filled %
      let filled = 0;
      for(let y=0;y<N;y++) for(let x=0;x<N;x++) if(grid[y][x]!==0) filled++;
      const pct = Math.round((filled/(N*N))*100);
      filledEl.textContent = String(pct);

      pieceInfo.textContent = `${currentPiece?.name ?? "—"} • size ${currentPiece ? pieceBounds(rotateCells(currentPiece.cells, pieceRot)).w : "?"}×${currentPiece ? pieceBounds(rotateCells(currentPiece.cells, pieceRot)).h : "?"} • placing tier ${placeTier}`;

      statusPill.textContent = alive ? "Alive" : "Dead";
      statusPill.style.borderColor = alive ? "rgba(72,211,138,.35)" : "rgba(255,204,102,.35)";
      statusPill.style.color = "rgba(231,238,252,1)";
    }

    // ====== Pointer events mapping ======
    function canvasToCell(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (canvas.width / rect.width);
      const y = (clientY - rect.top) * (canvas.height / rect.height);

      const W = canvas.width;
      const H = canvas.height;
      const gridSize = Math.min(W, H) - PAD*2;
      const cell = Math.floor((gridSize - (N-1)*CELL_GAP) / N);
      const startX = Math.floor((W - (cell*N + CELL_GAP*(N-1))) / 2);
      const startY = Math.floor((H - (cell*N + CELL_GAP*(N-1))) / 2);

      // Convert to cell
      const gx = x - startX;
      const gy = y - startY;

      if(gx < 0 || gy < 0) return null;

      const step = cell + CELL_GAP;
      const cx = Math.floor(gx / step);
      const cy = Math.floor(gy / step);

      if(cx < 0 || cx >= N || cy < 0 || cy >= N) return null;

      // If pointer is on the gap region, still allow (feels nicer)
      return {x: cx, y: cy};
    }

    let pointerDown = false;
    canvas.addEventListener('pointerdown', (e)=>{
      pointerDown = true;
      canvas.setPointerCapture(e.pointerId);
      const cell = canvasToCell(e.clientX, e.clientY);
      if(cell){
        hoverCell = cell;
        draw();
      }
    });

    canvas.addEventListener('pointermove', (e)=>{
      const cell = canvasToCell(e.clientX, e.clientY);
      hoverCell = cell;
      draw();
    });

    canvas.addEventListener('pointerup', (e)=>{
      pointerDown = false;
      const cell = canvasToCell(e.clientX, e.clientY);
      if(cell){
        hoverCell = cell;
        placeAt(cell.x, cell.y);
      }
    });

    canvas.addEventListener('pointerleave', ()=>{
      hoverCell = null;
      draw();
    });

    // ====== Keyboard controls ======
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'r' || e.key === 'R'){
        pieceRot = (pieceRot + 1) % 4;
        updateUI(); draw();
      }
      if(e.code === 'Space'){
        e.preventDefault();
        rerollPiece();
        showToast("Rerolled");
      }
      if(e.key === 'u' || e.key === 'U'){
        popHistory();
      }
    }, {passive:false});

    // Buttons
    document.getElementById('reset').addEventListener('click', resetRun);
    document.getElementById('newRun').addEventListener('click', resetRun);
    document.getElementById('undo').addEventListener('click', popHistory);
    modeSel.addEventListener('change', ()=>{
      showToast("Reaction changed");
    });

    // Init
    resetRun();

    // Small quality-of-life: keep crisp on resize
    function resizeCanvasForDPR(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.round(rect.width * dpr);
      const h = Math.round(rect.height * dpr);
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
        draw();
      }
    }
    const ro = new ResizeObserver(()=>{ resizeCanvasForDPR(); });
    ro.observe(canvas);
    resizeCanvasForDPR();

  </script>
</body>
</html>
```
